## MaskVote底层原理

### 生成分布式密钥

#### 生成私钥

1. $P_i$选择两个随机的t阶多项式，$f_i(z),f^`_i(z)$​​。
   $$
   f_i(z)=a_{i0}+a_{i1}z+...+a_{it}z^t\\
   f_i^`(z)=b_{i0}+b_{i1}z+...+b_{it}z^t
   $$
   其中$z_i=a_{i0}=f_i(0)$​。$P_i$公布$C_{ik}=g^{a_{ik}}h^{b_{ik}} \mod p$，其中$k=0,...,t$​。$P_i$​计算$s_{ij}=f_i(j),s^`_{ij}=f_i^`(j) \mod q$，其中$j=1,...,n$，并将$s_{ij},s^`_{ij}$​发送给$P_j$。

2. 每个$P_j$验证其它所有节点发来的共享信息。
   $$
   g^{s_{ij}}h^{s^`_{ij}} = \prod^t_{k=0}(C_{ik})^{j^{k}} \mod p
   $$
   如果验证不相等，$P_j$​会广播一个对$P_i$的申诉。

3. $P_i$​收到申诉后，公布向$P_j$发布的$s_{ij},s^`_{ij}$。

4. 如果$P_i$​收到了超过t个申诉后，会被淘汰，如果$P_j$发出的申诉被验证无效后，则$P_j$​会被淘汰。

5. $x = \sum_{i \in QUAL}z_i \mod q$，$P_i$设置分享的秘密为$x_i = \sum _{j\in QUAL}s_{ji} \mod q, x^`_i = \sum_{j\in QUAL}s^`_{ji} \mod q$​​，其中QUAL代表所有未被淘汰的节点。

#### 生成联合公钥

1. 每一个$P_i$，广播$A_{ik}=g^{a_{ik}} \mod p$，其中$k = 0,...,t$​。

2. 每一个$P_j$，验证其它节点广播的消息是否正确，如果不正确，广播一条对于$P_i$的申诉。
   $$
   g^{s_{ij}} = \prod^t_{k=0}(A_{ij})^{j^k} \mod p
   $$

3. 对于$P_i$​的申诉，一旦有一条是有效的，其它节点运行Pedersen-VSS，恢复$z_i, f_i(z), A_{ik} \ \ for \ \ k=0,...,t$。对于所有的QUAL节点，$y_i = A_{i0}=g^{z_i}\mod p$，计算$y=\prod_{i\in QUAL}y_i \mod p$

### 对于投票信息进行加密

1. voter首先对候选人进行投票，并用联合公钥，加密投票信息，并公布。
   $$
   E_Y(d) = (h^dY^r,g^r)
   $$
   $d\in\{0,1 \}$​，1代表同意，0代表不同意，r是随机数。

2. 对于以上的投票信息，提供零知识证明的相关凭证。需要证明使用了Y进行加密（可验证加密），d的值是非0即1的（范围证明），Y和h上的随机数相等（相等证明）。

### 联合解密

1. 首先对所有验证通过的选票相乘，
   $$
   E_Y(\sum d) = (h^{\sum d}Y^{\sum r},g^{\sum r}) = (h^{sum}Y^{R},g^R)
   $$
   其中$Y^R = (\prod_{i\in QUAL}y_i)^R=(\prod g^{z_i})^R=(g^R)^{\sum z_i}$​

2. voter用自己的私钥$z_i$​​加密$g^R$​​，并上传至链上。
3. 对于离线的voter，其它的voter根据之前该voter发送的$s_{ij}$​，恢复其私钥，并对$g^R$​​进行加密。
4. 求出$Y^R$​后，$h^{sum}$​可通过查表求得。

